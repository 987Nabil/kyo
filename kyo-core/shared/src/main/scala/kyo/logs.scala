package kyo

import org.slf4j.LoggerFactory

object Logs:
    // TODO: cannot make `private[kyo]` as it's used in KyoTest package, should it be private?
    // TODO: Perhaps this should be defined a version specific file to avoid the need to make LoggerFactory interop for JS?
    val unsafe: Unsafe = Unsafe(LoggerFactory.getLogger("kyo.logs"))
    given Unsafe       = unsafe

    trait Unsafe:
        def trace(msg: => String)(
            using
            file: sourcecode.FileName,
            line: sourcecode.Line
        ): Unit

        def trace(msg: => String, t: => Throwable)(
            using
            file: sourcecode.FileName,
            line: sourcecode.Line
        ): Unit

        def debug(msg: => String)(
            using
            file: sourcecode.FileName,
            line: sourcecode.Line
        ): Unit

        def debug(msg: => String, t: => Throwable)(
            using
            file: sourcecode.FileName,
            line: sourcecode.Line
        ): Unit < IOs
        def info(msg: => String)(
            using
            file: sourcecode.FileName,
            line: sourcecode.Line
        ): Unit

        def info(msg: => String, t: => Throwable)(
            using
            file: sourcecode.FileName,
            line: sourcecode.Line
        ): Unit

        def warn(msg: => String)(
            using
            file: sourcecode.FileName,
            line: sourcecode.Line
        ): Unit

        def warn(msg: => String, t: => Throwable)(
            using
            file: sourcecode.FileName,
            line: sourcecode.Line
        ): Unit

        def error(msg: => String)(
            using
            file: sourcecode.FileName,
            line: sourcecode.Line
        ): Unit

        def error(msg: => String, t: => Throwable)(
            using
            file: sourcecode.FileName,
            line: sourcecode.Line
        ): Unit
    end Unsafe

    object Unsafe:
        def apply(logger: org.slf4j.Logger): Unsafe = new Unsafe:
            def trace(msg: => String)(
                using
                file: sourcecode.FileName,
                line: sourcecode.Line
            ): Unit =
                // Discard wrappers so their allocation
                // can be elided by the JIT. The values
                // are `String`s from the constant pool
                // since they're generated by a macro.
                // This could be avoided if sourcecode's
                // values were `AnyVal`s.
                val f = file.value
                val l = line.value
                if logger.isTraceEnabled then logger.trace(s"[$f:$l] $msg")
            end trace

            def trace(msg: => String, t: => Throwable)(
                using
                file: sourcecode.FileName,
                line: sourcecode.Line
            ): Unit =
                val f = file.value
                val l = line.value
                if logger.isTraceEnabled then logger.trace(s"[$f:$l] $msg", t)
            end trace

            def debug(msg: => String)(
                using
                file: sourcecode.FileName,
                line: sourcecode.Line
            ): Unit =
                val f = file.value
                val l = line.value
                if logger.isDebugEnabled then logger.debug(s"[$f:$l] $msg")
            end debug

            def debug(msg: => String, t: => Throwable)(
                using
                file: sourcecode.FileName,
                line: sourcecode.Line
            ): Unit < IOs =
                val f = file.value
                val l = line.value
                if logger.isDebugEnabled then logger.debug(s"[$f:$l] $msg", t)
            end debug

            def info(msg: => String)(
                using
                file: sourcecode.FileName,
                line: sourcecode.Line
            ): Unit =
                val f = file.value
                val l = line.value
                if logger.isInfoEnabled then logger.info(s"[$f:$l] $msg")
            end info

            def info(msg: => String, t: => Throwable)(
                using
                file: sourcecode.FileName,
                line: sourcecode.Line
            ): Unit =
                val f = file.value
                val l = line.value
                if logger.isInfoEnabled then logger.info(s"[$f:$l] $msg", t)
            end info

            def warn(msg: => String)(
                using
                file: sourcecode.FileName,
                line: sourcecode.Line
            ): Unit =
                val f = file.value
                val l = line.value
                if logger.isWarnEnabled then logger.warn(s"[$f:$l] $msg")
            end warn

            def warn(msg: => String, t: => Throwable)(
                using
                file: sourcecode.FileName,
                line: sourcecode.Line
            ): Unit =
                val f = file.value
                val l = line.value
                if logger.isWarnEnabled then logger.warn(s"[$f:$l] $msg", t)
            end warn

            def error(msg: => String)(
                using
                file: sourcecode.FileName,
                line: sourcecode.Line
            ): Unit =
                val f = file.value
                val l = line.value
                if logger.isErrorEnabled then logger.error(s"[$f:$l] $msg")
            end error

            def error(msg: => String, t: => Throwable)(
                using
                file: sourcecode.FileName,
                line: sourcecode.Line
            ): Unit =
                val f = file.value
                val l = line.value
                if logger.isErrorEnabled then logger.error(s"[$f:$l] $msg", t)
            end error
    end Unsafe

    inline def trace(inline msg: => String)(
        using
        unsafe: Unsafe,
        file: sourcecode.FileName,
        line: sourcecode.Line
    ): Unit < IOs =
        // The suspended function will have two
        // pointers for `file` and `line`. It could be a
        // single pointer if sourcecode had an
        // implicit for `fileName:line`.
        IOs(unsafe.trace(msg))
    end trace

    inline def trace(inline msg: => String, inline t: => Throwable)(
        using
        unsafe: Unsafe,
        file: sourcecode.FileName,
        line: sourcecode.Line
    ): Unit < IOs = IOs(unsafe.trace(msg, t))

    inline def debug(inline msg: => String)(
        using
        unsafe: Unsafe,
        file: sourcecode.FileName,
        line: sourcecode.Line
    ): Unit < IOs =
        IOs(unsafe.debug(msg))

    inline def debug(inline msg: => String, inline t: => Throwable)(
        using
        unsafe: Unsafe,
        file: sourcecode.FileName,
        line: sourcecode.Line
    ): Unit < IOs =
        IOs(unsafe.debug(msg, t))

    inline def info(inline msg: => String)(
        using
        unsafe: Unsafe,
        file: sourcecode.FileName,
        line: sourcecode.Line
    ): Unit < IOs =
        IOs(unsafe.info(msg))

    inline def info(inline msg: => String, inline t: => Throwable)(
        using
        unsafe: Unsafe,
        file: sourcecode.FileName,
        line: sourcecode.Line
    ): Unit < IOs =
        IOs(unsafe.info(msg, t))

    inline def warn(inline msg: => String)(
        using
        unsafe: Unsafe,
        file: sourcecode.FileName,
        line: sourcecode.Line
    ): Unit < IOs =
        IOs(unsafe.warn(msg))

    inline def warn(inline msg: => String, inline t: => Throwable)(
        using
        unsafe: Unsafe,
        file: sourcecode.FileName,
        line: sourcecode.Line
    ): Unit < IOs =
        IOs(unsafe.warn(msg, t))

    inline def error(inline msg: => String)(
        using
        unsafe: Unsafe,
        file: sourcecode.FileName,
        line: sourcecode.Line
    ): Unit < IOs =
        IOs(unsafe.error(msg))

    inline def error(inline msg: => String, inline t: => Throwable)(
        using
        unsafe: Unsafe,
        file: sourcecode.FileName,
        line: sourcecode.Line
    ): Unit < IOs =
        IOs(unsafe.error(msg, t))
end Logs
